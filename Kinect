//------------------------------------------------------------------------------
// <copyright file="MainWindow.xaml.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
//動作環境　OS　windows10　SOFTWARE　Visual　Studio　2017 言語C＃
namespace Microsoft.Samples.Kinect.BodyBasics
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Windows;
    using System.Windows.Forms;
    using System.Windows.Media;
    using System.Windows.Media.Imaging;
    using System.Windows.Threading;
    using Microsoft.Kinect;
    using System.Runtime.InteropServices;
    using MusicStart;

    /// <summary>
    /// Interaction logic for MainWindow
    /// </summary>

    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        /// <summary>
        /// Radius of drawn hand circles
        /// </summary>
        private const double HandSize = 30;

        /// <summary>
        /// Thickness of drawn joint lines
        /// </summary>
        private const double JointThickness = 3;

        /// <summary>
        /// Thickness of clip edge rectangles
        /// </summary>
        private const double ClipBoundsThickness = 10;

        /// <summary>
        /// Constant for clamping Z values of camera space points from being negative
        /// </summary>
        private const float InferredZPositionClamp = 0.1f;

        /// <summary>
        /// Brush used for drawing joints that are currently tracked
        /// </summary>
        private readonly Brush trackedJointBrush = new SolidColorBrush(Color.FromArgb(255, 68, 192, 68));

        /// <summary>
        /// Brush used for drawing joints that are currently inferred
        /// </summary>        
        private readonly Brush inferredJointBrush = Brushes.Yellow;

        /// <summary>
        /// Pen used for drawing bones that are currently inferred
        /// </summary>        
        private readonly Pen inferredBonePen = new Pen(Brushes.Gray, 1);

        /// <summary>
        /// Drawing group for body rendering output
        /// </summary>
        private DrawingGroup drawingGroup;

        /// <summary>
        /// Drawing image that we will display
        /// </summary>
        private DrawingImage imageSource;

        /// <summary>
        /// Active Kinect sensor
        /// </summary>
        private KinectSensor kinectSensor = null;

        /// <summary>
        /// Coordinate mapper to map one type of point to another
        /// </summary>
        private CoordinateMapper coordinateMapper = null;

        /// <summary>
        /// Reader for body frames
        /// </summary>
        private BodyFrameReader bodyFrameReader = null;

        /// <summary>
        /// Array for the bodies
        /// </summary>
        private Body[] bodies = null;

        /// <summary>
        /// definition of bones
        /// </summary>
        private List<Tuple<JointType, JointType>> bones;

        /// <summary>
        /// Width of display (depth space)
        /// </summary>
        private int displayWidth;

        /// <summary>
        /// Height of display (depth space)
        /// </summary>
        private int displayHeight;

        /// <summary>
        /// List of colors for each body tracked
        /// </summary>
        private List<Pen> bodyColors;

        /// <summary>
        /// Current status text to display
        /// </summary>
        private string statusText = null;

        /// <summary>
        /// Initializes a new instance of the MainWindow class.
        /// </summary>

        //***************************************************************************************************
        public static int stop_flag = 0, delay = 0, count = 0, sstart_flag = 0, start_flag = 0;
        public static double headResult = 0, elbowLeftResult = 0, elbowRightResult = 0, wristLeftResult = 0, wristRightResult = 0, kneeLeftResult = 0, kneeRightResult = 0, ankleLeftResult = 0, ankleRightResult = 0;
        public static double headFlag_x = 0, headFlag_y = 0, elbowLeftFlag_x = 0, elbowLeftFlag_y = 0, elbowRightFlag_x = 0, elbowRightFlag_y = 0, wristLeftFlag_x = 0, wristLeftFlag_y = 0, wristRightFlag_x = 0, wristRightFlag_y = 0, kneeLeftFlag_x = 0, kneeLeftFlag_y = 0, kneeRightFlag_x = 0, kneeRightFlag_y = 0, ankleLeftFlag_x = 0, ankleLeftFlag_y = 0, ankleRightFlag_x = 0, ankleRightFlag_y = 0;
        public static double judge_x = 0, judge_y = 0, judgeMargin = 0, tall_t = 0, tall_p = 0;

        public static double[] head_x = new double[1000000];
        public static double[] head_y = new double[1000000];
        public static double[] neck_x = new double[1000000];
        public static double[] neck_y = new double[1000000];
        public static double[] spineShoulder_x = new double[1000000];
        public static double[] spineShoulder_y = new double[1000000];
        public static double[] shoulderLeft_x = new double[1000000];
        public static double[] shoulderLeft_y = new double[1000000];
        public static double[] shoulderRight_x = new double[1000000];
        public static double[] shoulderRight_y = new double[1000000];
        public static double[] elbowLeft_x = new double[1000000];
        public static double[] elbowLeft_y = new double[1000000];
        public static double[] elbowRight_x = new double[1000000];
        public static double[] elbowRight_y = new double[1000000];
        public static double[] wristLeft_x = new double[1000000];
        public static double[] wristLeft_y = new double[1000000];
        public static double[] wristRight_x = new double[1000000];
        public static double[] wristRight_y = new double[1000000];
        public static double[] handTipLeft_x = new double[1000000];
        public static double[] handTipLeft_y = new double[1000000];
        public static double[] handTipRight_x = new double[1000000];
        public static double[] handTipRight_y = new double[1000000];
        public static double[] spineMid_x = new double[1000000];
        public static double[] spineMid_y = new double[1000000];
        public static double[] spineBase_x = new double[1000000];
        public static double[] spineBase_y = new double[1000000];
        public static double[] hipLeft_x = new double[1000000];
        public static double[] hipLeft_y = new double[1000000];
        public static double[] hipRight_x = new double[1000000];
        public static double[] hipRight_y = new double[1000000];
        public static double[] kneeLeft_x = new double[1000000];
        public static double[] kneeLeft_y = new double[1000000];
        public static double[] kneeRight_x = new double[1000000];
        public static double[] kneeRight_y = new double[1000000];
        public static double[] ankleLeft_x = new double[1000000];
        public static double[] ankleLeft_y = new double[1000000];
        public static double[] ankleRight_x = new double[1000000];
        public static double[] ankleRight_y = new double[1000000];
        public static double[] footLeft_x = new double[1000000];
        public static double[] footLeft_y = new double[1000000];
        public static double[] footRight_x = new double[1000000];
        public static double[] footRight_y = new double[1000000];

        public static string filename = "C:\\m\\FLOWER.wav";

        // 動画のパス
        private readonly string _videoPath = "C:\\m\\FLOWER.wmv";


        private void JudgeBox_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            //☆これがないと怒られる(エラーを吐く)
        }
        //***************************************************************************************************



        public MainWindow()
        {
            // one sensor is currently supported
            this.kinectSensor = KinectSensor.GetDefault();

            // get the coordinate mapper
            this.coordinateMapper = this.kinectSensor.CoordinateMapper;

            // get the depth (display) extents
            FrameDescription frameDescription = this.kinectSensor.DepthFrameSource.FrameDescription;

            // get size of joint space
            this.displayWidth = frameDescription.Width;
            this.displayHeight = frameDescription.Height;

            // open the reader for the body frames
            this.bodyFrameReader = this.kinectSensor.BodyFrameSource.OpenReader();

            // a bone defined as a line between two joints
            this.bones = new List<Tuple<JointType, JointType>>();

            // Torso
            this.bones.Add(new Tuple<JointType, JointType>(JointType.Head, JointType.Neck));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.Neck, JointType.SpineShoulder));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineShoulder, JointType.SpineMid));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineMid, JointType.SpineBase));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineShoulder, JointType.ShoulderRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineShoulder, JointType.ShoulderLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineBase, JointType.HipRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineBase, JointType.HipLeft));

            // Right Arm
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ShoulderRight, JointType.ElbowRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ElbowRight, JointType.WristRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristRight, JointType.HandRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HandRight, JointType.HandTipRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristRight, JointType.ThumbRight));

            // Left Arm
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ShoulderLeft, JointType.ElbowLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ElbowLeft, JointType.WristLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristLeft, JointType.HandLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HandLeft, JointType.HandTipLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristLeft, JointType.ThumbLeft));

            // Right Leg
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HipRight, JointType.KneeRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.KneeRight, JointType.AnkleRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.AnkleRight, JointType.FootRight));

            // Left Leg
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HipLeft, JointType.KneeLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.KneeLeft, JointType.AnkleLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.AnkleLeft, JointType.FootLeft));

            // populate body colors, one for each BodyIndex
            this.bodyColors = new List<Pen>();

            this.bodyColors.Add(new Pen(Brushes.Aqua, 6)); //☆棒人間の描画カラーを統一
            this.bodyColors.Add(new Pen(Brushes.Aqua, 6));
            this.bodyColors.Add(new Pen(Brushes.Aqua, 6));
            this.bodyColors.Add(new Pen(Brushes.Aqua, 6));
            this.bodyColors.Add(new Pen(Brushes.Aqua, 6));
            this.bodyColors.Add(new Pen(Brushes.Red, 6));

            /*this.bodyColors.Add(new Pen(Brushes.Red, 6));
            this.bodyColors.Add(new Pen(Brushes.Orange, 6));
            this.bodyColors.Add(new Pen(Brushes.Green, 6));
            this.bodyColors.Add(new Pen(Brushes.Blue, 6));
            this.bodyColors.Add(new Pen(Brushes.Indigo, 6));
            this.bodyColors.Add(new Pen(Brushes.Violet, 6));*/

            // set IsAvailableChanged event notifier
            this.kinectSensor.IsAvailableChanged += this.Sensor_IsAvailableChanged;

            // open the sensor
            this.kinectSensor.Open();

            // set the status text
            this.StatusText = this.kinectSensor.IsAvailable ? Properties.Resources.RunningStatusText
                                                            : Properties.Resources.NoSensorStatusText;

            // Create the drawing group we'll use for drawing
            this.drawingGroup = new DrawingGroup();

            // Create an image source that we can use in our image control
            this.imageSource = new DrawingImage(this.drawingGroup);

            // use the window object as the view model in this simple example
            this.DataContext = this;

            // initialize the components (controls) of the window
            this.InitializeComponent();
        }

        /// <summary>
        /// INotifyPropertyChangedPropertyChanged event to allow window controls to bind to changeable data
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Gets the bitmap to display
        /// </summary>
        public ImageSource ImageSource
        {
            get
            {
                return this.imageSource;
            }
        }

        /// <summary>
        /// Gets or sets the current status text to display
        /// </summary>
        public string StatusText
        {
            get
            {
                return this.statusText;
            }

            set
            {
                if (this.statusText != value)
                {
                    this.statusText = value;

                    // notify any bound elements that the text has changed
                    if (this.PropertyChanged != null)
                    {
                        this.PropertyChanged(this, new PropertyChangedEventArgs("StatusText"));
                    }
                }
            }
        }

        /// <summary>
        /// Execute start up tasks
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            if (this.bodyFrameReader != null)
            {
                this.bodyFrameReader.FrameArrived += this.Reader_FrameArrived;
            }

            //***************************************************************************************************
            /*head_x.Initialize();
            head_y.Initialize();
            elbowLeft_x.Initialize();
            elbowLeft_y.Initialize();
            elbowRight_x.Initialize();
            elbowRight_y.Initialize();
            wristLeft_x.Initialize();
            wristLeft_y.Initialize();
            wristRight_x.Initialize();
            wristRight_y.Initialize();
            spineMid_x.Initialize();
            spineMid_y.Initialize();
            spineBase_x.Initialize();
            spineBase_y.Initialize();
            kneeLeft_x.Initialize();
            kneeLeft_y.Initialize();
            kneeRight_x.Initialize();
            kneeRight_y.Initialize();
            ankleLeft_x.Initialize();
            ankleLeft_y.Initialize();
            ankleRight_x.Initialize();
            ankleRight_y.Initialize();*/
            ExcelRead.ExcelRead.Read(ref head_x,ref head_y, ref elbowLeft_x, ref elbowLeft_y, ref elbowRight_x, ref elbowRight_y, ref wristLeft_x, ref wristLeft_y, ref wristRight_x, ref wristRight_y, ref spineMid_x, ref spineMid_y, ref spineBase_x, ref spineBase_y, ref kneeLeft_x, ref kneeLeft_y, ref kneeRight_x, ref kneeRight_y, ref ankleLeft_x, ref ankleLeft_y, ref ankleRight_x, ref ankleRight_y);
            //☆Excelの読み込み　参照渡しで配列を全て送っている
            //***************************************************************************************************
        }


        /// <summary>
        /// Execute shutdown tasks
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void MainWindow_Closing(object sender, CancelEventArgs e)
        {
            if (stop_flag == 1) SendKeys.SendWait("^(+(r))");
            if (this.bodyFrameReader != null)
            {
                // BodyFrameReader is IDisposable
                this.bodyFrameReader.Dispose();
                this.bodyFrameReader = null;
            }

            if (this.kinectSensor != null)
            {
                this.kinectSensor.Close();
                this.kinectSensor = null;
            }
        }

        /// <summary>
        /// Handles the body frame data arriving from the sensor
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void Reader_FrameArrived(object sender, BodyFrameArrivedEventArgs e)
        {
            bool dataReceived = false;

            using (BodyFrame bodyFrame = e.FrameReference.AcquireFrame())
            {
                if (bodyFrame != null)
                {
                    if (this.bodies == null)
                    {
                        this.bodies = new Body[bodyFrame.BodyCount];
                    }

                    // The first time GetAndRefreshBodyData is called, Kinect will allocate each Body in the array.
                    // As long as those body objects are not disposed and not set to null in the array,
                    // those body objects will be re-used.
                    bodyFrame.GetAndRefreshBodyData(this.bodies);
                    dataReceived = true;
                }
            }

            if (dataReceived)
            {
                using (DrawingContext dc = this.drawingGroup.Open())
                {
                    // Draw a transparent background to set the render size
                    dc.DrawRectangle(Brushes.Transparent, null, new Rect(0.0, 0.0, this.displayWidth, this.displayHeight));

                    int penIndex = 0;
                    foreach (Body body in this.bodies)
                    {
                        if (penIndex == 4) penIndex = 0;
                        Pen drawPen = this.bodyColors[penIndex++];

                        if (body.IsTracked)
                        {
                            this.DrawClippedEdges(body, dc);

                            IReadOnlyDictionary<JointType, Joint> joints = body.Joints;

                            // convert the joint points to depth (display) space
                            Dictionary<JointType, Point> jointPoints = new Dictionary<JointType, Point>();

                            foreach (JointType jointType in joints.Keys)
                            {
                                // sometimes the depth(Z) of an inferred joint may show as negative
                                // clamp down to 0.1f to prevent coordinatemapper from returning (-Infinity, -Infinity)
                                CameraSpacePoint position = joints[jointType].Position;
                                if (position.Z < 0)
                                {
                                    position.Z = InferredZPositionClamp;
                                }

                                DepthSpacePoint depthSpacePoint = this.coordinateMapper.MapCameraPointToDepthSpace(position);
                                jointPoints[jointType] = new Point(depthSpacePoint.X, depthSpacePoint.Y);
                            }

                            this.DrawBody(joints, jointPoints, dc, drawPen);

                            DrawJudgeCircle(dc, jointPoints[JointType.Head], jointPoints[JointType.ElbowLeft], jointPoints[JointType.ElbowRight], jointPoints[JointType.WristLeft], jointPoints[JointType.WristRight], jointPoints[JointType.KneeLeft], jointPoints[JointType.KneeRight], jointPoints[JointType.AnkleLeft], jointPoints[JointType.AnkleRight]);
                            //☆判定円の描画
                        }
                    }

                    // prevent drawing outside of our render area
                    this.drawingGroup.ClipGeometry = new RectangleGeometry(new Rect(0.0, 0.0, this.displayWidth, this.displayHeight));
                }
            }

            if (sstart_flag == 1) //☆ボタンを押してから3秒待つためにやむなく追加
            {
                delay++; //☆1フレームごとに1増える(30fpsだから1/30秒で1増える)
                if (delay < 30) button1.Content = "3";
                else if (delay >= 30 && delay < 60) button1.Content = "2";
                else if (delay >= 60 && delay < 90) button1.Content = "1";
                else
                {
                    button1.Content = "Stop"; //☆Startボタンの表示をストップに
                    stop_flag = 1; //☆2回目以降にボタンが押された時にリザルトを表示する
                    start_flag = 1; //☆取得+比較開始
                    SendKeys.SendWait("^(+(r))"); //☆録画の開始

                    MediaElementMovie.Source = new Uri(_videoPath, UriKind.Relative); //☆再生する動画の指定
                    MediaElementMovie.Play(); //☆動画の再生開始
                    sstart_flag = 0; //再び3秒のカウントダウンが始まるのを阻止
                    count = 0; //☆保存してある上級者のデータの初めのフレーム(1フレームごとに配列に格納されてる)から読み込み開始
                }
            }
        }

        /// <summary>
        /// Draws a body
        /// </summary>
        /// <param name="joints">joints to draw</param>
        /// <param name="jointPoints">translated positions of joints to draw</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        /// <param name="drawingPen">specifies color to draw a specific body</param>
        private void DrawBody(IReadOnlyDictionary<JointType, Joint> joints, IDictionary<JointType, Point> jointPoints, DrawingContext drawingContext, Pen drawingPen)
        {
            if (start_flag == 1)
            {
                // Draw the bones
                foreach (var bone in this.bones)
                {
                    this.DrawBone(joints, jointPoints, bone.Item1, bone.Item2, drawingContext, drawingPen);
                }


                // Draw the joints
                foreach (JointType jointType in joints.Keys)
                {
                    Brush drawBrush = null;

                    TrackingState trackingState = joints[jointType].TrackingState;

                    if (trackingState == TrackingState.Tracked)
                    {
                        drawBrush = this.trackedJointBrush;
                    }
                    else if (trackingState == TrackingState.Inferred)
                    {
                        drawBrush = this.inferredJointBrush;
                    }

                    if (drawBrush != null)
                    {
                        drawingContext.DrawEllipse(drawBrush, null, jointPoints[jointType], JointThickness, JointThickness);
                    }
                }

                //***************************************************************************************************


                tall_t = spineBase_y[count] - spineMid_y[count]; //☆仮身長の算出
                tall_p = jointPoints[JointType.SpineBase].Y - jointPoints[JointType.SpineMid].Y;


                judge_x = (head_x[count] - spineBase_x[count]) - (jointPoints[JointType.Head].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (head_y[count] - spineBase_y[count]) - (jointPoints[JointType.Head].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    headFlag_x = judge_x;
                    headResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    headFlag_y = judge_y;
                    headResult += 0.5;
                }

                judge_x = (elbowLeft_x[count] - spineBase_x[count]) - (jointPoints[JointType.ElbowLeft].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (elbowLeft_y[count] - spineBase_y[count]) - (jointPoints[JointType.ElbowLeft].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    elbowLeftFlag_x = judge_x;
                    elbowLeftResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    elbowLeftFlag_y = judge_y;
                    elbowLeftResult += 0.5;
                }

                judge_x = (elbowRight_x[count] - spineBase_x[count]) - (jointPoints[JointType.ElbowRight].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (elbowRight_y[count] - spineBase_y[count]) - (jointPoints[JointType.ElbowRight].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    elbowRightFlag_x = judge_x;
                    elbowRightResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    elbowRightFlag_y = judge_y;
                    elbowRightResult += 0.5;
                }

                judge_x = (wristLeft_x[count] - spineBase_x[count]) - (jointPoints[JointType.WristLeft].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (wristLeft_y[count] - spineBase_y[count]) - (jointPoints[JointType.WristLeft].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    wristLeftFlag_x = judge_x;
                    wristLeftResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    wristLeftFlag_y = judge_y;
                    wristLeftResult += 0.5;
                }

                judge_x = (wristRight_x[count] - spineBase_x[count]) - (jointPoints[JointType.WristRight].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (wristRight_y[count] - spineBase_y[count]) - (jointPoints[JointType.WristRight].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    wristRightFlag_x = judge_x;
                    wristRightResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    wristRightFlag_y = judge_y;
                    wristRightResult += 0.5;
                }

                judge_x = (kneeLeft_x[count] - spineBase_x[count]) - (jointPoints[JointType.KneeLeft].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (kneeLeft_y[count] - spineBase_y[count]) - (jointPoints[JointType.KneeLeft].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    kneeLeftFlag_x = judge_x;
                    kneeLeftResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    kneeLeftFlag_y = judge_y;
                    kneeLeftResult += 0.5;
                }

                judge_x = (kneeRight_x[count] - spineBase_x[count]) - (jointPoints[JointType.KneeRight].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (kneeRight_y[count] - spineBase_y[count]) - (jointPoints[JointType.KneeRight].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    kneeRightFlag_x = judge_x;
                    kneeRightResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    kneeRightFlag_y = judge_y;
                    kneeRightResult += 0.5;
                }

                judge_x = (ankleLeft_x[count] - spineBase_x[count]) - (jointPoints[JointType.AnkleLeft].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (ankleLeft_y[count] - spineBase_y[count]) - (jointPoints[JointType.AnkleLeft].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin))
                {
                    ankleLeftFlag_x = judge_x;
                    ankleLeftResult += 0.5;
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    ankleLeftFlag_y = judge_y;
                    ankleLeftResult += 0.5;
                }

                judge_x = (ankleRight_x[count] - spineBase_x[count]) - (jointPoints[JointType.AnkleRight].X - jointPoints[JointType.SpineBase].X) * tall_t / tall_p;
                judge_y = (ankleLeft_y[count] - spineBase_y[count]) - (jointPoints[JointType.AnkleLeft].Y - jointPoints[JointType.SpineBase].Y) * tall_t / tall_p;
                //☆ベクトル計算(詳しくは発表スライドを見るか神威にLINE)
                if (Math.Abs(judge_x) > Math.Abs(judgeMargin)) //☆絶対値で判定の甘さと比較
                {
                    ankleRightFlag_x = judge_x; //☆ズレの円を描くのに使用
                    ankleRightResult += 0.5; //☆一致率に使用　1フレームで最大1増える(x,yそれぞれ0.5ずつ)　最後に総フレーム数で割る
                }
                if (Math.Abs(judge_y) > Math.Abs(judgeMargin))
                {
                    ankleRightFlag_y = judge_y;
                    ankleRightResult += 0.5;
                }

                count++; //☆次のフレームの座標を読み込む
            }
            //***************************************************************************************************
        }

        /// <summary>
        /// Draws one bone of a body (joint to joint)
        /// </summary>
        /// <param name="joints">joints to draw</param>
        /// <param name="jointPoints">translated positions of joints to draw</param>
        /// <param name="jointType0">first joint of bone to draw</param>
        /// <param name="jointType1">second joint of bone to draw</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        /// /// <param name="drawingPen">specifies color to draw a specific bone</param>
        private void DrawBone(IReadOnlyDictionary<JointType, Joint> joints, IDictionary<JointType, Point> jointPoints, JointType jointType0, JointType jointType1, DrawingContext drawingContext, Pen drawingPen)
        {
            Joint joint0 = joints[jointType0];
            Joint joint1 = joints[jointType1];

            // If we can't find either of these joints, exit
            if (joint0.TrackingState == TrackingState.NotTracked ||
                joint1.TrackingState == TrackingState.NotTracked)
            {
                return;
            }

            // We assume all drawn bones are inferred unless BOTH joints are tracked
            Pen drawPen = this.inferredBonePen;
            if ((joint0.TrackingState == TrackingState.Tracked) && (joint1.TrackingState == TrackingState.Tracked))
            {
                drawPen = drawingPen;
            }

            drawingContext.DrawLine(drawPen, jointPoints[jointType0], jointPoints[jointType1]);
        }

        /// <summary>
        /// Draws a hand symbol if the hand is tracked: red circle = closed, green circle = opened; blue circle = lasso
        /// </summary>
        /// <param name="handState">state of the hand</param>
        /// <param name="handPosition">position of the hand</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        private void DrawJudgeCircle(DrawingContext drawingContext, Point headPosition, Point elbowLeftPosition, Point elbowRightPosition, Point wristLeftPosition, Point wristRightPosition, Point kneeLeftPosition, Point kneeRightPosition, Point ankleLeftPosition, Point ankleRightPosition)
        { //☆ズレた場所に円を表示する
            if (headFlag_x != 0 || headFlag_y != 0)
            {
                if (headFlag_x > 155) headFlag_x = 155;
                if (headFlag_y > 155) headFlag_y = 155;
                if (headFlag_x < -155) headFlag_x = -155;
                if (headFlag_y < -155) headFlag_y = -155;

                if (headFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (headFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - headFlag_y), (byte)(headFlag_x + 100), 0, 0)), null, headPosition, 20, 20);
                    else if (headFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(headFlag_x + 100), 0, 0)), null, headPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(headFlag_x + 100), (byte)(headFlag_y * -1 + 100), 0)), null, headPosition, 20, 20);
                }
                else if (headFlag_x == 0)
                {
                    if (headFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - headFlag_y), 0, 0, 0)), null, headPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(headFlag_y * -1 + 100), 0)), null, headPosition, 20, 20);
                }
                else
                {
                    if (headFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - headFlag_y), 0, 0, (byte)(headFlag_x * -1 + 100))), null, headPosition, 20, 20);
                    else if (headFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(headFlag_x * -1 + 100))), null, headPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(headFlag_y * -1 + 100), (byte)(headFlag_x * -1 + 100))), null, headPosition, 20, 20);
                }
                headFlag_x = 0;
                headFlag_y = 0;
            }

            if (elbowLeftFlag_x != 0 || elbowLeftFlag_y != 0)
            {
                if (elbowLeftFlag_x > 155) elbowLeftFlag_x = 155;
                if (elbowLeftFlag_y > 155) elbowLeftFlag_y = 155;
                if (elbowLeftFlag_x < -155) elbowLeftFlag_x = -155;
                if (elbowLeftFlag_y < -155) elbowLeftFlag_y = -155;

                if (elbowLeftFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (elbowLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - elbowLeftFlag_y), (byte)(elbowLeftFlag_x + 100), 0, 0)), null, elbowLeftPosition, 20, 20);
                    else if (elbowLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(elbowLeftFlag_x + 100), 0, 0)), null, elbowLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(elbowLeftFlag_x + 100), (byte)(elbowLeftFlag_y * -1 + 100), 0)), null, elbowLeftPosition, 20, 20);
                }
                else if (elbowLeftFlag_x == 0)
                {
                    if (elbowLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - elbowLeftFlag_y), 0, 0, 0)), null, elbowLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(elbowLeftFlag_y * -1 + 100), 0)), null, elbowLeftPosition, 20, 20);
                }
                else
                {
                    if (elbowLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - elbowLeftFlag_y), 0, 0, (byte)(elbowLeftFlag_x * -1 + 100))), null, elbowLeftPosition, 20, 20);
                    else if (elbowLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(elbowLeftFlag_x * -1 + 100))), null, elbowLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(elbowLeftFlag_y * -1 + 100), (byte)(elbowLeftFlag_x * -1 + 100))), null, elbowLeftPosition, 20, 20);
                }
                elbowLeftFlag_x = 0;
                elbowLeftFlag_y = 0;
            }

            if (elbowRightFlag_x != 0 || elbowRightFlag_y != 0)
            {
                if (elbowRightFlag_x > 155) elbowRightFlag_x = 155;
                if (elbowRightFlag_y > 155) elbowRightFlag_y = 155;
                if (elbowRightFlag_x < -155) elbowRightFlag_x = -155;
                if (elbowRightFlag_y < -155) elbowRightFlag_y = -155;

                if (elbowRightFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (elbowRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - elbowRightFlag_y), (byte)(elbowRightFlag_x + 100), 0, 0)), null, elbowRightPosition, 20, 20);
                    else if (elbowRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(elbowRightFlag_x + 100), 0, 0)), null, elbowRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(elbowRightFlag_x + 100), (byte)(elbowRightFlag_y * -1 + 100), 0)), null, elbowRightPosition, 20, 20);
                }
                else if (elbowRightFlag_x == 0)
                {
                    if (elbowRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - elbowRightFlag_y), 0, 0, 0)), null, elbowRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(elbowRightFlag_y * -1 + 100), 0)), null, elbowRightPosition, 20, 20);
                }
                else
                {
                    if (elbowRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - elbowRightFlag_y), 0, 0, (byte)(elbowRightFlag_x * -1 + 100))), null, elbowRightPosition, 20, 20);
                    else if (elbowRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(elbowRightFlag_x * -1 + 100))), null, elbowRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(elbowRightFlag_y * -1 + 100), (byte)(elbowRightFlag_x * -1 + 100))), null, elbowRightPosition, 20, 20);
                }
                elbowRightFlag_x = 0;
                elbowRightFlag_y = 0;
            }

            if (wristLeftFlag_x != 0 || wristLeftFlag_y != 0)
            {
                if (wristLeftFlag_x > 155) wristLeftFlag_x = 155;
                if (wristLeftFlag_y > 155) wristLeftFlag_y = 155;
                if (wristLeftFlag_x < -155) wristLeftFlag_x = -155;
                if (wristLeftFlag_y < -155) wristLeftFlag_y = -155;

                if (wristLeftFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (wristLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - wristLeftFlag_y), (byte)(wristLeftFlag_x + 100), 0, 0)), null, wristLeftPosition, 20, 20);
                    else if (wristLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(wristLeftFlag_x + 100), 0, 0)), null, wristLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(wristLeftFlag_x + 100), (byte)(wristLeftFlag_y * -1 + 100), 0)), null, wristLeftPosition, 20, 20);
                }
                else if (wristLeftFlag_x == 0)
                {
                    if (wristLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - wristLeftFlag_y), 0, 0, 0)), null, wristLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(wristLeftFlag_y * -1 + 100), 0)), null, wristLeftPosition, 20, 20);
                }
                else
                {
                    if (wristLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - wristLeftFlag_y), 0, 0, (byte)(wristLeftFlag_x * -1 + 100))), null, wristLeftPosition, 20, 20);
                    else if (wristLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(wristLeftFlag_x * -1 + 100))), null, wristLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(wristLeftFlag_y * -1 + 100), (byte)(wristLeftFlag_x * -1 + 100))), null, wristLeftPosition, 20, 20);
                }
                wristLeftFlag_x = 0;
                wristLeftFlag_y = 0;
            }

            if (wristRightFlag_x != 0 || wristRightFlag_y != 0)
            {
                if (wristRightFlag_x > 155) wristRightFlag_x = 155;
                if (wristRightFlag_y > 155) wristRightFlag_y = 155;
                if (wristRightFlag_x < -155) wristRightFlag_x = -155;
                if (wristRightFlag_y < -155) wristRightFlag_y = -155;

                if (wristRightFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (wristRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - wristRightFlag_y), (byte)(wristRightFlag_x + 100), 0, 0)), null, wristRightPosition, 20, 20);
                    else if(wristRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(wristRightFlag_x + 100), 0, 0)), null, wristRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(wristRightFlag_x + 100), (byte)(wristRightFlag_y * -1 + 100), 0)), null, wristRightPosition, 20, 20);
                }
                else if (wristRightFlag_x == 0)
                {
                    if(wristRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - wristRightFlag_y), 0, 0, 0)), null, wristRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(wristRightFlag_y * -1 + 100), 0)), null, wristRightPosition, 20, 20);
                }
                else
                {
                    if (wristRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - wristRightFlag_y), 0, 0, (byte)(wristRightFlag_x * -1 + 100))), null, wristRightPosition, 20, 20);
                    else if (wristRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(wristRightFlag_x * -1 + 100))), null, wristRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(wristRightFlag_y * -1 + 100), (byte)(wristRightFlag_x * -1 + 100))), null, wristRightPosition, 20, 20);
                }
                wristRightFlag_x = 0;
                wristRightFlag_y = 0;
            }

            if (kneeLeftFlag_x != 0 || kneeLeftFlag_y != 0)
            {
                if (kneeLeftFlag_x > 155) kneeLeftFlag_x = 155;
                if (kneeLeftFlag_y > 155) kneeLeftFlag_y = 155;
                if (kneeLeftFlag_x < -155) kneeLeftFlag_x = -155;
                if (kneeLeftFlag_y < -155) kneeLeftFlag_y = -155;

                if (kneeLeftFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (kneeLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - kneeLeftFlag_y), (byte)(kneeLeftFlag_x + 100), 0, 0)), null, kneeLeftPosition, 20, 20);
                    else if (kneeLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(kneeLeftFlag_x + 100), 0, 0)), null, kneeLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(kneeLeftFlag_x + 100), (byte)(kneeLeftFlag_y * -1 + 100), 0)), null, kneeLeftPosition, 20, 20);
                }
                else if (kneeLeftFlag_x == 0)
                {
                    if (kneeLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - kneeLeftFlag_y), 0, 0, 0)), null, kneeLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(kneeLeftFlag_y * -1 + 100), 0)), null, kneeLeftPosition, 20, 20);
                }
                else
                {
                    if (kneeLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - kneeLeftFlag_y), 0, 0, (byte)(kneeLeftFlag_x * -1 + 100))), null, kneeLeftPosition, 20, 20);
                    else if (kneeLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(kneeLeftFlag_x * -1 + 100))), null, kneeLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(kneeLeftFlag_y * -1 + 100), (byte)(kneeLeftFlag_x * -1 + 100))), null, kneeLeftPosition, 20, 20);
                }
                kneeLeftFlag_x = 0;
                kneeLeftFlag_y = 0;
            }

            if (kneeRightFlag_x != 0 || kneeRightFlag_y != 0)
            {
                if (kneeRightFlag_x > 155) kneeRightFlag_x = 155;
                if (kneeRightFlag_y > 155) kneeRightFlag_y = 155;
                if (kneeRightFlag_x < -155) kneeRightFlag_x = -155;
                if (kneeRightFlag_y < -155) kneeRightFlag_y = -155;

                if (kneeRightFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (kneeRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - kneeRightFlag_y), (byte)(kneeRightFlag_x + 100), 0, 0)), null, kneeRightPosition, 20, 20);
                    else if (kneeRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(kneeRightFlag_x + 100), 0, 0)), null, kneeRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(kneeRightFlag_x + 100), (byte)(kneeRightFlag_y * -1 + 100), 0)), null, kneeRightPosition, 20, 20);
                }
                else if (kneeRightFlag_x == 0)
                {
                    if (kneeRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - kneeRightFlag_y), 0, 0, 0)), null, kneeRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(kneeRightFlag_y * -1 + 100), 0)), null, kneeRightPosition, 20, 20);
                }
                else
                {
                    if (kneeRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - kneeRightFlag_y), 0, 0, (byte)(kneeRightFlag_x * -1 + 100))), null, kneeRightPosition, 20, 20);
                    else if (kneeRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(kneeRightFlag_x * -1 + 100))), null, kneeRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(kneeRightFlag_y * -1 + 100), (byte)(kneeRightFlag_x * -1 + 100))), null, kneeRightPosition, 20, 20);
                }
                kneeRightFlag_x = 0;
                kneeRightFlag_y = 0;
            }

            if (ankleLeftFlag_x != 0 || ankleLeftFlag_y != 0)
            {
                if (ankleLeftFlag_x > 155) ankleLeftFlag_x = 155;
                if (ankleLeftFlag_y > 155) ankleLeftFlag_y = 155;
                if (ankleLeftFlag_x < -155) ankleLeftFlag_x = -155;
                if (ankleLeftFlag_y < -155) ankleLeftFlag_y = -155;

                if (ankleLeftFlag_x > 0) //上:a 下:g 右:b 左:r
                {
                    if (ankleLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - ankleLeftFlag_y), (byte)(ankleLeftFlag_x + 100), 0, 0)), null, ankleLeftPosition, 20, 20);
                    else if (ankleLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(ankleLeftFlag_x + 100), 0, 0)), null, ankleLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(ankleLeftFlag_x + 100), (byte)(ankleLeftFlag_y * -1 + 100), 0)), null, ankleLeftPosition, 20, 20);
                }
                else if (ankleLeftFlag_x == 0)
                {
                    if (ankleLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - ankleLeftFlag_y), 0, 0, 0)), null, ankleLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(ankleLeftFlag_y * -1 + 100), 0)), null, ankleLeftPosition, 20, 20);
                }
                else
                {
                    if (ankleLeftFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - ankleLeftFlag_y), 0, 0, (byte)(ankleLeftFlag_x * -1 + 100))), null, ankleLeftPosition, 20, 20);
                    else if (ankleLeftFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(ankleLeftFlag_x * -1 + 100))), null, ankleLeftPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(ankleLeftFlag_y * -1 + 100), (byte)(ankleLeftFlag_x * -1 + 100))), null, ankleLeftPosition, 20, 20);
                }
                ankleLeftFlag_x = 0;
                ankleLeftFlag_y = 0;
            }

            if (ankleRightFlag_x != 0 || ankleRightFlag_y != 0)
            {
                if (ankleRightFlag_x > 155) ankleRightFlag_x = 155; //☆オーバーフローしないため(100からスタート)
                if (ankleRightFlag_y > 155) ankleRightFlag_y = 155;
                if (ankleRightFlag_x < -155) ankleRightFlag_x = -155;
                if (ankleRightFlag_y < -155) ankleRightFlag_y = -155;

                if (ankleRightFlag_x > 0) //☆上:a 下:g 右:b 左:r
                {
                    if (ankleRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - ankleRightFlag_y), (byte)(ankleRightFlag_x + 100), 0, 0)), null, ankleRightPosition, 20, 20);
                    else if (ankleRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(ankleRightFlag_x + 100), 0, 0)), null, ankleRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, (byte)(ankleRightFlag_x + 100), (byte)(ankleRightFlag_y * -1 + 100), 0)), null, ankleRightPosition, 20, 20);
                } //☆x成分が正にズレていて①y成分も正にズレている②y成分はズレてない③yが負にズレている
                else if (ankleRightFlag_x == 0)
                {
                    if (ankleRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - ankleRightFlag_y), 0, 0, 0)), null, ankleRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(ankleRightFlag_y * -1 + 100), 0)), null, ankleRightPosition, 20, 20);
                }
                else
                {
                    if (ankleRightFlag_y > 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb((byte)(155 - ankleRightFlag_y), 0, 0, (byte)(ankleRightFlag_x * -1 + 100))), null, ankleRightPosition, 20, 20);
                    else if (ankleRightFlag_y == 0) drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, 0, (byte)(ankleRightFlag_x * -1 + 100))), null, ankleRightPosition, 20, 20);
                    else drawingContext.DrawEllipse(new SolidColorBrush(Color.FromArgb(255, 0, (byte)(ankleRightFlag_y * -1 + 100), (byte)(ankleRightFlag_x * -1 + 100))), null, ankleRightPosition, 20, 20);
                }
                ankleRightFlag_x = 0;
                ankleRightFlag_y = 0;
            }
        }

        //***************************************************************************************************
        private void button1_Click_1(object sender, RoutedEventArgs e)
        {
            //MusicStart.PlaySound(filename);

            if (stop_flag == 1) //☆一致率計算&リザルト画面表示 stop_flagがあるのは一番最初にクリックされたときにも表示されるのを防ぐため
            {
                SendKeys.SendWait("^(+(r))"); //☆録画の停止(Windowsのゲームバーで画面キャプチャのショートカットキーを設定しておく)

                MediaElementMovie.Visibility = Visibility.Hidden;
                Window1 result = new Window1();
                result.headLabel.Content = 100 * (1 - headResult / count);
                result.elbowLeftLabel.Content = 100 * (1 - elbowLeftResult / count);
                result.elbowRightLabel.Content = 100 * (1 - elbowRightResult / count);
                result.wristLeftLabel.Content = 100 * (1 - wristLeftResult / count);
                result.wristRightLabel.Content = 100 * (1 - wristRightResult / count);
                result.kneeLeftLabel.Content = 100 * (1 - kneeLeftResult / count);
                result.kneeRightLabel.Content = 100 * (1 - kneeRightResult / count);
                result.ankleLeftLabel.Content = 100 * (1 - ankleLeftResult / count);
                result.ankleRightLabel.Content = 100 * (1 - ankleRightResult / count);
                result.Show();
            }



            judgeMargin = Convert.ToDouble(JudgeBox.Text); //☆判定の甘さをdouble型の変数に格納
            JudgeBox.IsEnabled = false; //☆入力ボックスを無効に
            JudgeBox.Visibility = Visibility.Hidden; //☆非表示に
            JudgeLabel.Visibility = Visibility.Hidden; //☆ボックスの上の日本語を非表示

        }
        //***************************************************************************************************

        /// <summary>
        /// Draws indicators to show which edges are clipping body data
        /// </summary>
        /// <param name="body">body to draw clipping information for</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        private void DrawClippedEdges(Body body, DrawingContext drawingContext)
        {
            FrameEdges clippedEdges = body.ClippedEdges;

            if (clippedEdges.HasFlag(FrameEdges.Bottom))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(0, this.displayHeight - ClipBoundsThickness, this.displayWidth, ClipBoundsThickness));
            }

            if (clippedEdges.HasFlag(FrameEdges.Top))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(0, 0, this.displayWidth, ClipBoundsThickness));
            }

            if (clippedEdges.HasFlag(FrameEdges.Left))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(0, 0, ClipBoundsThickness, this.displayHeight));
            }

            if (clippedEdges.HasFlag(FrameEdges.Right))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(this.displayWidth - ClipBoundsThickness, 0, ClipBoundsThickness, this.displayHeight));
            }
        }

        /// <summary>
        /// Handles the event which the sensor becomes unavailable (E.g. paused, closed, unplugged).
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void Sensor_IsAvailableChanged(object sender, IsAvailableChangedEventArgs e)
        {
            // on failure, set the status text
            this.StatusText = this.kinectSensor.IsAvailable ? Properties.Resources.RunningStatusText
                                                            : Properties.Resources.SensorNotAvailableStatusText;
        }
    }
}
